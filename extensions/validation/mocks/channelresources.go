// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"

	"github.com/hyperledger/fabric-protos-go/common"
	"github.com/hyperledger/fabric/common/channelconfig"
	"github.com/hyperledger/fabric/core/ledger"
	"github.com/hyperledger/fabric/msp"
)

type ChannelResources struct {
	MSPManagerStub        func() msp.MSPManager
	mSPManagerMutex       sync.RWMutex
	mSPManagerArgsForCall []struct{}
	mSPManagerReturns     struct {
		result1 msp.MSPManager
	}
	mSPManagerReturnsOnCall map[int]struct {
		result1 msp.MSPManager
	}
	ApplyStub        func(configtx *common.ConfigEnvelope) error
	applyMutex       sync.RWMutex
	applyArgsForCall []struct {
		configtx *common.ConfigEnvelope
	}
	applyReturns struct {
		result1 error
	}
	applyReturnsOnCall map[int]struct {
		result1 error
	}
	GetMSPIDsStub        func() []string
	getMSPIDsMutex       sync.RWMutex
	getMSPIDsArgsForCall []struct{}
	getMSPIDsReturns     struct {
		result1 []string
	}
	getMSPIDsReturnsOnCall map[int]struct {
		result1 []string
	}
	CapabilitiesStub        func() channelconfig.ApplicationCapabilities
	capabilitiesMutex       sync.RWMutex
	capabilitiesArgsForCall []struct{}
	capabilitiesReturns     struct {
		result1 channelconfig.ApplicationCapabilities
	}
	capabilitiesReturnsOnCall map[int]struct {
		result1 channelconfig.ApplicationCapabilities
	}
	LedgerStub        func() ledger.PeerLedger
	ledgerMutex       sync.RWMutex
	ledgerArgsForCall []struct{}
	ledgerReturns     struct {
		result1 ledger.PeerLedger
	}
	ledgerReturnsOnCall map[int]struct {
		result1 ledger.PeerLedger
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *ChannelResources) MSPManager() msp.MSPManager {
	fake.mSPManagerMutex.Lock()
	ret, specificReturn := fake.mSPManagerReturnsOnCall[len(fake.mSPManagerArgsForCall)]
	fake.mSPManagerArgsForCall = append(fake.mSPManagerArgsForCall, struct{}{})
	fake.recordInvocation("MSPManager", []interface{}{})
	fake.mSPManagerMutex.Unlock()
	if fake.MSPManagerStub != nil {
		return fake.MSPManagerStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.mSPManagerReturns.result1
}

func (fake *ChannelResources) MSPManagerCallCount() int {
	fake.mSPManagerMutex.RLock()
	defer fake.mSPManagerMutex.RUnlock()
	return len(fake.mSPManagerArgsForCall)
}

func (fake *ChannelResources) MSPManagerReturns(result1 msp.MSPManager) {
	fake.MSPManagerStub = nil
	fake.mSPManagerReturns = struct {
		result1 msp.MSPManager
	}{result1}
}

func (fake *ChannelResources) MSPManagerReturnsOnCall(i int, result1 msp.MSPManager) {
	fake.MSPManagerStub = nil
	if fake.mSPManagerReturnsOnCall == nil {
		fake.mSPManagerReturnsOnCall = make(map[int]struct {
			result1 msp.MSPManager
		})
	}
	fake.mSPManagerReturnsOnCall[i] = struct {
		result1 msp.MSPManager
	}{result1}
}

func (fake *ChannelResources) Apply(configtx *common.ConfigEnvelope) error {
	fake.applyMutex.Lock()
	ret, specificReturn := fake.applyReturnsOnCall[len(fake.applyArgsForCall)]
	fake.applyArgsForCall = append(fake.applyArgsForCall, struct {
		configtx *common.ConfigEnvelope
	}{configtx})
	fake.recordInvocation("Apply", []interface{}{configtx})
	fake.applyMutex.Unlock()
	if fake.ApplyStub != nil {
		return fake.ApplyStub(configtx)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.applyReturns.result1
}

func (fake *ChannelResources) ApplyCallCount() int {
	fake.applyMutex.RLock()
	defer fake.applyMutex.RUnlock()
	return len(fake.applyArgsForCall)
}

func (fake *ChannelResources) ApplyArgsForCall(i int) *common.ConfigEnvelope {
	fake.applyMutex.RLock()
	defer fake.applyMutex.RUnlock()
	return fake.applyArgsForCall[i].configtx
}

func (fake *ChannelResources) ApplyReturns(result1 error) {
	fake.ApplyStub = nil
	fake.applyReturns = struct {
		result1 error
	}{result1}
}

func (fake *ChannelResources) ApplyReturnsOnCall(i int, result1 error) {
	fake.ApplyStub = nil
	if fake.applyReturnsOnCall == nil {
		fake.applyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.applyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *ChannelResources) GetMSPIDs() []string {
	fake.getMSPIDsMutex.Lock()
	ret, specificReturn := fake.getMSPIDsReturnsOnCall[len(fake.getMSPIDsArgsForCall)]
	fake.getMSPIDsArgsForCall = append(fake.getMSPIDsArgsForCall, struct{}{})
	fake.recordInvocation("GetMSPIDs", []interface{}{})
	fake.getMSPIDsMutex.Unlock()
	if fake.GetMSPIDsStub != nil {
		return fake.GetMSPIDsStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getMSPIDsReturns.result1
}

func (fake *ChannelResources) GetMSPIDsCallCount() int {
	fake.getMSPIDsMutex.RLock()
	defer fake.getMSPIDsMutex.RUnlock()
	return len(fake.getMSPIDsArgsForCall)
}

func (fake *ChannelResources) GetMSPIDsReturns(result1 []string) {
	fake.GetMSPIDsStub = nil
	fake.getMSPIDsReturns = struct {
		result1 []string
	}{result1}
}

func (fake *ChannelResources) GetMSPIDsReturnsOnCall(i int, result1 []string) {
	fake.GetMSPIDsStub = nil
	if fake.getMSPIDsReturnsOnCall == nil {
		fake.getMSPIDsReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.getMSPIDsReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *ChannelResources) Capabilities() channelconfig.ApplicationCapabilities {
	fake.capabilitiesMutex.Lock()
	ret, specificReturn := fake.capabilitiesReturnsOnCall[len(fake.capabilitiesArgsForCall)]
	fake.capabilitiesArgsForCall = append(fake.capabilitiesArgsForCall, struct{}{})
	fake.recordInvocation("Capabilities", []interface{}{})
	fake.capabilitiesMutex.Unlock()
	if fake.CapabilitiesStub != nil {
		return fake.CapabilitiesStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.capabilitiesReturns.result1
}

func (fake *ChannelResources) CapabilitiesCallCount() int {
	fake.capabilitiesMutex.RLock()
	defer fake.capabilitiesMutex.RUnlock()
	return len(fake.capabilitiesArgsForCall)
}

func (fake *ChannelResources) CapabilitiesReturns(result1 channelconfig.ApplicationCapabilities) {
	fake.CapabilitiesStub = nil
	fake.capabilitiesReturns = struct {
		result1 channelconfig.ApplicationCapabilities
	}{result1}
}

func (fake *ChannelResources) CapabilitiesReturnsOnCall(i int, result1 channelconfig.ApplicationCapabilities) {
	fake.CapabilitiesStub = nil
	if fake.capabilitiesReturnsOnCall == nil {
		fake.capabilitiesReturnsOnCall = make(map[int]struct {
			result1 channelconfig.ApplicationCapabilities
		})
	}
	fake.capabilitiesReturnsOnCall[i] = struct {
		result1 channelconfig.ApplicationCapabilities
	}{result1}
}

func (fake *ChannelResources) Ledger() ledger.PeerLedger {
	fake.ledgerMutex.Lock()
	ret, specificReturn := fake.ledgerReturnsOnCall[len(fake.ledgerArgsForCall)]
	fake.ledgerArgsForCall = append(fake.ledgerArgsForCall, struct{}{})
	fake.recordInvocation("Ledger", []interface{}{})
	fake.ledgerMutex.Unlock()
	if fake.LedgerStub != nil {
		return fake.LedgerStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.ledgerReturns.result1
}

func (fake *ChannelResources) LedgerCallCount() int {
	fake.ledgerMutex.RLock()
	defer fake.ledgerMutex.RUnlock()
	return len(fake.ledgerArgsForCall)
}

func (fake *ChannelResources) LedgerReturns(result1 ledger.PeerLedger) {
	fake.LedgerStub = nil
	fake.ledgerReturns = struct {
		result1 ledger.PeerLedger
	}{result1}
}

func (fake *ChannelResources) LedgerReturnsOnCall(i int, result1 ledger.PeerLedger) {
	fake.LedgerStub = nil
	if fake.ledgerReturnsOnCall == nil {
		fake.ledgerReturnsOnCall = make(map[int]struct {
			result1 ledger.PeerLedger
		})
	}
	fake.ledgerReturnsOnCall[i] = struct {
		result1 ledger.PeerLedger
	}{result1}
}

func (fake *ChannelResources) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.mSPManagerMutex.RLock()
	defer fake.mSPManagerMutex.RUnlock()
	fake.applyMutex.RLock()
	defer fake.applyMutex.RUnlock()
	fake.getMSPIDsMutex.RLock()
	defer fake.getMSPIDsMutex.RUnlock()
	fake.capabilitiesMutex.RLock()
	defer fake.capabilitiesMutex.RUnlock()
	fake.ledgerMutex.RLock()
	defer fake.ledgerMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *ChannelResources) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
